#!/bin/sh
#
# Copyright 2015-2017 GaÃ«l PORTAY <gael.portay@gmail.com>
#
# Licensed under the MIT license.
#

set -e

PREFIX=/var/lib/mpkg
VERSION=0.1.6
UPDATE=false

cleanup() {
	local rc=$?
	$DO_CLEANUP
	exit $rc
}

die() {
	echo "Error: $*" >&2
	exit 1
}

lock() {
	install -d "${1%/*}/"
	touch "$1"
}

get_value() {
	sed -n "/$1:/s#.*: *##p"
}

get_pkg() {
	if [ -z "$2" ]; then
		sed -n -e "/Package: $1$/,/^\$/p"
	else
		sed -n -e "/Package: $1$/,/^$/{/Version: ${2:-.*}$/,/^$/p}" | \
		sed    -e "/Version: ${2:-.*}$/iPackage: $1"
	fi
}

download() {
	wget -qO- "$1" $WGETOPTS
}

fetch() {
	install -d "${2%/*}/"
	if echo "$1" | grep -qE '^file://'; then
		cp "${1##*://}" "$2"
	else
		download "$1" >"$2"
	fi
}

pkg_extract_metadata() {
	tar xzf "$1" -C "$2"           ${PREFIX#*/} $TAROPTS
}

pkg_extract_data() {
	tar xzf "$1" -C "$2" --exclude=${PREFIX#*/} $TAROPTS
}

pkg_remove_metadata() {
	rm -r "$ROOT$PREFIX/info/$1"
}

pkg_remove_data() {
	cat "$ROOT$PREFIX/info/$1/files" 2>/dev/null | while read f; do
		rm -f "$ROOT$f"
	done
}

pkg_run_script() {
	local infodir
	local script
	infodir=$1
	script=$2
	shift
	shift

	if [ -x "$infodir/$script" ]; then
		echo -n "${infodir##*/}: Running $script... "
		if ! ${FORCE:+true} "$infodir/$script" "$@"; then
			echo "failed!"
			return 1
		fi
		echo "done"
	fi
}

pkg_status() {
	cat "$ROOT$PREFIX/info/$1/control" 2>/dev/null
}

pkg_get_needs() {
	local needs
	local need
	for need in "$ROOT$PREFIX/info/$1/needs/"*; do
		if [ ! -h "$need" ]; then
			break
		fi

		needs="$needs ${need##*/}"
	done

	if [ -z "$needs" ]; then
		return 1
	fi

	echo "${needs# *}"
}

pkg_get_required_by() {
	local required
	local req
	for req in "$ROOT$PREFIX/info/$1/required-by/"*; do
		if [ ! -h "$req" ]; then
			break
		fi

		required="$required ${req##*/}"
	done

	if [ -z "$required" ]; then
		return 1
	fi

	echo "${required# *}"
}

version_lt() {
	echo "$*" | awk '{
	split($1, val, ".");
	split($2, ref, ".");

	i = 1;
	while (val[i] != "" || ref[i] != "") {
		if (val[i] == "" || val[i] < ref[i]) {
			ret = -1;
			break;
		}
		else if (ref[i] == "" || val[i] > ref[i]) {
			ret = 1;
			break;
		}

		i++;
	}

	if (ret >= 0) {
		exit 1
	}
}'
}

version_latest() {
	local ref
	read ref

	local v
	while read v; do
		if ! version_lt "$v" "$ref"; then
			ref=$v
		fi
	done
	echo "$ref"
}

feed_get_pkg_latest() {
	local version
	for feed in "$ROOT$PREFIX/lists/"*; do
		if [ ! -f "$feed" ]; then
			break
		fi

		version=$(cat "$feed" | get_pkg "$pkg" | get_value "Version" | version_latest)
		if [ -n "$version" ]; then
			break
		fi
	done

	if [ -n "$version" ]; then
		echo "$version"
	fi
}

pkg_fetch() {
	local pkg
	local destdir
	local version
	pkg=$1
	destdir=$2
	version=$3

	# Find the latest version
	if [ -z "$version" ]; then
		version=$(feed_get_pkg_latest "$pkg")
	fi

	# Find which feed provides package
	local filename=
	for feed in "$ROOT$PREFIX/lists/"*; do
		if [ ! -f "$feed" ]; then
			break
		fi

		filename=$(cat "$feed" | get_pkg "$pkg" "$version" | get_value "Filename")
		if [ -n "$filename" ]; then
			break
		fi
	done

	if [ -z "$filename" ]; then
		echo "$pkg: Cannot find package in feeds!" >&2
		return 1
	fi

	# Fetch package
	local file
	local url
	file=${filename##*/}
	url=$(grep -E "^${feed##*/} " "$ROOT/etc/mpkg/feeds.conf" | cut -d' ' -f2)
	if [ ! -e "$cachedir/$file" ]; then
		if ! fetch "${url%/*}/$filename" "$cachedir/$file"; then
			return 1
		fi
	fi

	# Check package
	local md5
	md5=$(cat "$feed" | get_pkg "$pkg" "$version" | get_value "MD5Sum" | tail -n1)
	echo "$md5  $file" >"$cachedir/$file.md5"
	if [ -e "$cachedir/$file" ]; then
		if ( cd "$cachedir/" && ! md5sum --quiet --check "$file.md5" ); then
			echo -n "$pkg: Mismatch MD5! "
			md5sum "$cachedir/$file" | cut -d' ' -f1
			rm -f "$cachedir/$file"*
			return 1
		fi >&2
	fi

	if [ -n "$destdir" ] && [ "$destdir" != "$cachedir" ]; then
		mv "$cachedir/$file" "$cachedir/$file.md5" "$destdir"
	fi

	echo "$file"
}

pkg_install() {
	local pkg
	local ver
	pkg=$1
	ver=$2
	if ! ${REDO:-false} && pkg_status "$pkg" >/dev/null; then
		if [ -n "${requiredby##* }" ]; then
			ln -sf "../../$pkg" "$ROOT$PREFIX/info/$pkg/required-by/${requiredby##* }"
		fi
		return
	fi

	echo "$pkg: Installing package${requiredby:+ required by$requiredby}..."

	# Fetching package
	echo "$pkg: Fetching package..."
	local file
	file=$(pkg_fetch "$pkg" "$cachedir" "$ver")
	if [ -z "$file" ]; then
		return 1
	fi

	# Extract package data
	echo "$pkg: Unarchiving package meta-data..."
	pkg_extract_metadata "$cachedir/$file" "$tmpdir"
	install -d "$tmpdir$PREFIX/info/$pkg/needs/"
	install -d "$tmpdir$PREFIX/info/$pkg/required-by/"

	# Run preinst script if exists
	if ! pkg_run_script "$tmpdir$PREFIX/info/$pkg" preinst install; then
		echo "$pkg: Failed to run preinst!" >&2
		return 1
	fi

	# Install missing dependencies
	local depends
	local dep
	depends=$(cat "$tmpdir$PREFIX/info/$pkg/control" | get_value 'Depends')
	for dep in $depends; do
		requiredby="$requiredby $pkg"
		if ! pkg_install "$dep"; then
			abort=true
			break;
		fi
		requiredby="${requiredby% *}"

		ln -sf "../../$dep" "$tmpdir$PREFIX/info/$pkg/needs/$dep"
	done

	# Installation abort by a dependency
	if $abort; then
		local rmdepends
		local rmdep
		echo "$pkg: Installation abort due to $dep!"
		rmdepends=" $depends "
		echo "$pkg: Auto-removing${rmdepends}dependencies!" >&2

		# Remove required-by symlink to unlock for removal
		for dep in $rmdepends; do
			rm -f "$ROOT$PREFIX/info/$dep/required-by/$pkg"
		done

		# Removing auto-installed dependencies
		for rmdep in $rmdepends; do
			if [ -e "$ROOT$PREFIX/info/$rmdep/.user" ]; then
				echo "Warning: Do not auto-remove user-installed package $rmdep! Keep going..." >&2
				continue
			fi

			if ! pkg_remove "$rmdep"; then
				echo "Warning: Failed to remove package $rmdep! Keep going..." >&2
			fi

			rm -f "$tmpdir$PREFIX/info/$pkg/needs/$rmdep"
		done

		return 1
	fi

	# Extract whole archive
	echo "$pkg: Unarchiving package data..."
	pkg_extract_data "$cachedir/$file" "${ROOT:-/}"

	# Installing files
	install -d "$ROOT$PREFIX/info/"
	mv "$tmpdir$PREFIX/info/$pkg/" "$ROOT$PREFIX/info/"
	rm "$cachedir/$file"*

	# Run postinst script if exists,
	# and add the configure flag if the script fails
	if ! pkg_run_script "$ROOT$PREFIX/info/$pkg" postinst configure; then
		touch "$ROOT$PREFIX/info/$pkg/.configure"
		echo "$pkg: Failed to run postinst!" >&2
	fi

	# Add the user flag if the package is not required by any other package,
	# it means it has been installed by the user
	if [ -z "$requiredby" ]; then
		touch "$ROOT$PREFIX/info/$pkg/.user"
	fi

	# Add required-by symlink to lock for removal
	if [ -n "${requiredby##* }" ]; then
		ln -sf "../../$pkg" "$ROOT$PREFIX/info/$pkg/required-by/${requiredby##* }"
	fi

	echo "$pkg: Package installed!"
}

pkg_remove() {
	local pkg
	pkg=$1
	if ! pkg_status "$pkg" >/dev/null; then
		return
	elif required_by=$(pkg_get_required_by "$pkg"); then
		echo "Error: $pkg: Cannot remove package! It is required by: $required_by." >&2
		return 1
	fi

	# Run prerm script if exists
	if ! pkg_run_script "$ROOT$PREFIX/info/$pkg" prerm remove; then
		echo "$pkg: Failed to run prerm!" >&2
		return 1
	fi

	echo "$pkg: Removing package${autoremovedby:+ auto-removed by$autoremovedby}..."

	local depends
	local dep
	depends=$(pkg_status "$pkg" | get_pkg "$pkg" | get_value 'Depends')
	for dep in $depends; do
		rm -f "$ROOT$PREFIX/info/$dep/required-by/$pkg"
	done

	# Removing auto-installed dependencies
	for dep in $depends; do
		autoremovedby="$autoremovedby $pkg"
		if [ -e "$ROOT$PREFIX/info/$dep/.user" ]; then
			echo "Warning: Do not auto-remove user-installed package $dep! Keep going..." >&2
			continue
		fi

		if ! pkg_remove "$dep"; then
			abort=true
			break;
		fi
		autoremovedby="${autoremovedby% *}"
	done

	# Removing files
	echo "$pkg: Removing package data..."
	pkg_remove_data "$pkg"

	# Run postrm script if exists,
	if ! pkg_run_script "$ROOT$PREFIX/info/$pkg" postrm remove; then
		echo "$pkg: Failed to run postrm!" >&2
	fi
	pkg_remove_metadata "$pkg"

	echo "$pkg: Package removed!"
}

do_update() {
	install -d "$ROOT$PREFIX/lists/"
	sed -e '/^#/d' "$ROOT/etc/mpkg/feeds.conf" 2>/dev/null | while read name url; do
		if [ -z "$url" ]; then
			echo "Warning: Invalid line \"$name\"!" >&2
			continue
		fi

		echo -n "Updating feed $name at $url... "
		fetch "$url" "$ROOT$PREFIX/lists/$name"
		md5sum "$ROOT$PREFIX/lists/$name" | cut -d' ' -f1
	done
}

do_list_installed() {
	local ctrl
	for ctrl in $ROOT$PREFIX/info/*/control; do
		if [ ! -f "$ctrl" ]; then
			break
		fi

		local pkg
		pkg=${ctrl#$ROOT$PREFIX/info/}
		pkg=${pkg%/control}

		cat "$ctrl"
		if [ -f "${ctrl%/*}/.user" ]; then
			echo "User-Installed: yes"
		fi
		if [ -f "${ctrl%/*}/.configure" ]; then
			echo "Configure-Required: yes"
		fi
		local needs
		if needs=$(pkg_get_needs "$pkg"); then
			echo "MPKG-Needs: $needs"
		fi
		local required_by
		if required_by=$(pkg_get_required_by "$pkg"); then
			echo "MPKG-Required-by: $required_by"
		fi
		echo ""
	done
}

do_status() {
	for pkg in "$@"; do
		if pkg_status "$pkg"; then
			echo
		fi
	done
}

do_fetch() {
	for pkg in "$@"; do
		echo "Fetching package $pkg..."
		pkg_fetch "$pkg" ./
	done
}

do_install() {
	install -d "$tmpdir$PREFIX/"
	for pkg in "$@"; do
		abort=false
		name=$(echo "$pkg" | cut -d_ -f1)
		ver=$(echo "$pkg" | cut -d_ -f2)
		ver=${ver#$pkg}
		if ! ${REDO:-false} && pkg_status "$name" >/dev/null; then
			echo "$name: Package already installed!"
			continue
		fi

		echo "Installing package $name..."
		requiredby=
		if ! pkg_install "$name" "$ver"; then
			die "Failed to install $name!"
		fi
		echo "Package $name installed!"
	done
}

do_remove() {
	for pkg in "$@"; do
		abort=false
		if ! pkg_status "$pkg" >/dev/null; then
			echo "$pkg: Package not installed!"
			continue
		fi

		echo "Removing package $pkg..."
		autoremovedby=
		if ! pkg_remove "$pkg"; then
			die "Failed to remove $pkg!"
		fi
		echo "Package $pkg removed!"
	done
}

usage() {
	cat <<EOF
Usage: ${0##*/} [OPTIONS] update
       ${0##*/} [OPTIONS] list-installed
       ${0##*/} [OPTIONS] status PACKAGE...
       ${0##*/} [OPTIONS] fetch PACKAGE...
       ${0##*/} [OPTIONS] install|remove PACKAGE[_VERSION]...

Options:
 -f or --force         Force.
 -r or --root DIR      To set the root directory.
 -h or --help          Display this message.
 -V or --version       Display the version.

Options for install:
 -u or --update        To update index first.
 --redo                Redo.
EOF
}

parse_arguments() {
	UPDATE=false

	while [ $# -ne 0 ]; do
		if [ "$1" = "-f" ] || [ "$1" = "--force" ]; then
			FORCE=true
		elif [ "$1" = "-r" ] || [ "$1" = "--root" ]; then
			shift
			ROOT="$(realpath "$1" 2>/dev/null || ( cd "$1/" && pwd ))"
			export ROOT
		elif [ "$1" = "--redo" ]; then
			REDO=true
		elif [ "$1" = "-u" ] || [ "$1" = "--update" ]; then
			UPDATE=true
		elif [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
			usage
			exit 0
		elif [ "$1" = "-V" ] || [ "$1" = "--version" ]; then
			echo $VERSION
			exit 0
		elif [ -z "$func" ]; then
			if echo "$func" | grep -qE "update|list-installed|status|fetch|install|remove"; then
				usage >&2
				echo  >&2
				die "$1: Unknown function!"
			fi
			func="$1"
		elif echo "$func" | grep -qE "fetch|install|remove"; then
			args="$args $1"
		elif [ -z "$args" ]; then
			args="$args $1"
		else
			usage >&2
			echo  >&2
			die "Too many arguments!"
		fi
		shift
	done
}

parse_arguments "$@"

lockfile=$ROOT/var/run/mpkg/.lock
cachedir=$ROOT/var/cache/mpkg
tmpdir=$(mktemp -d "$ROOT/tmp/${0##*/}-XXXXXX" 2>/dev/null || echo "$ROOT/tmp/${0##*/}-$$")
DO_CLEANUP="rm -Rf $tmpdir"
trap cleanup 0 INT

if [ -e "$lockfile" ]; then
	die "Only one single instance should run at a time!"
fi

DO_CLEANUP="$DO_CLEANUP ; rm -f $lockfile ;"
lock "$lockfile"

case "$func" in
update)
	do_update
	;;
list-installed)
	do_list_installed
	;;
fetch)
	if [ -z "$args" ]; then
		usage >&2
		echo  >&2
		die "Too few arguments!"
	fi

	if $UPDATE; then
		do_update
	fi

	do_fetch $args
	;;
status)
	if [ -z "$args" ]; then
		usage >&2
		echo  >&2
		die "Too few arguments!"
	fi

	do_status $args
	;;
install)
	if [ -z "$args" ]; then
		usage >&2
		echo  >&2
		die "Too few arguments!"
	fi

	if $UPDATE; then
		do_update
	fi

	do_install $args
	;;
remove)
	if [ -z "$args" ]; then
		usage >&2
		echo  >&2
		die "Too few arguments!"
	fi

	do_remove $args
	;;
*)
	usage >&2
	echo  >&2

	die "Too few arguments!"
	;;
esac
